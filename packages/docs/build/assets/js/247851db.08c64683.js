"use strict";(self.webpackChunknext_auth_docs=self.webpackChunknext_auth_docs||[]).push([[7195],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return f}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),h=l(t),f=o,d=h["".concat(c,".").concat(f)]||h[f]||p[f]||s;return t?r.createElement(d,a(a({ref:n},u),{},{components:t})):r.createElement(d,a({ref:n},u))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=t.length,a=new Array(s);a[0]=h;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,a[1]=i;for(var l=2;l<s;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},5977:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return h}});var r=t(7462),o=t(3366),s=(t(7294),t(3905)),a=["components"],i={id:"refresh-token-rotation",title:"Refresh Token Rotation"},c=void 0,l={unversionedId:"tutorials/refresh-token-rotation",id:"tutorials/refresh-token-rotation",isDocsHomePage:!1,title:"Refresh Token Rotation",description:"While NextAuth.js doesn't automatically handle access token rotation for OAuth providers yet, this functionality can be implemented using callbacks.",source:"@site/docs/tutorials/refresh-token-rotation.md",sourceDirName:"tutorials",slug:"/tutorials/refresh-token-rotation",permalink:"/tutorials/refresh-token-rotation",editUrl:"https://github.com/nextauthjs/docs/edit/main/docs/tutorials/refresh-token-rotation.md",tags:[],version:"current",lastUpdatedBy:"Bal\xe1zs Orb\xe1n",lastUpdatedAt:1643982356,formattedLastUpdatedAt:"2/4/2022",frontMatter:{id:"refresh-token-rotation",title:"Refresh Token Rotation"}},u=[{value:"Source Code",id:"source-code",children:[],level:2},{value:"Implementation",id:"implementation",children:[{value:"Server Side",id:"server-side",children:[],level:3},{value:"Client Side",id:"client-side",children:[],level:3}],level:2}],p={toc:u};function h(e){var n=e.components,t=(0,o.Z)(e,a);return(0,s.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"While NextAuth.js doesn't automatically handle access token rotation for OAuth providers yet, this functionality can be implemented using ",(0,s.kt)("a",{parentName:"p",href:"https://next-auth.js.org/configuration/callbacks"},"callbacks"),"."),(0,s.kt)("h2",{id:"source-code"},"Source Code"),(0,s.kt)("p",null,"A working example can be accessed ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/nextauthjs/next-auth-refresh-token-example"},"here"),"."),(0,s.kt)("h2",{id:"implementation"},"Implementation"),(0,s.kt)("h3",{id:"server-side"},"Server Side"),(0,s.kt)("p",null,"Using a ",(0,s.kt)("a",{parentName:"p",href:"https://next-auth.js.org/configuration/callbacks#jwt-callback"},"JWT callback")," and a ",(0,s.kt)("a",{parentName:"p",href:"https://next-auth.js.org/configuration/callbacks#session-callback"},"session callback"),", we can persist OAuth tokens and refresh them when they expire."),(0,s.kt)("p",null,"Below is a sample implementation using Google's Identity Provider. Please note that the OAuth 2.0 request in the ",(0,s.kt)("inlineCode",{parentName:"p"},"refreshAccessToken()")," function will vary between different providers, but the core logic should remain similar."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="pages/auth/[...nextauth.js]"',title:'"pages/auth/[...nextauth.js]"'},'import NextAuth from "next-auth"\nimport GoogleProvider from "next-auth/providers/google"\n\nconst GOOGLE_AUTHORIZATION_URL =\n  "https://accounts.google.com/o/oauth2/v2/auth?" +\n  new URLSearchParams({\n    prompt: "consent",\n    access_type: "offline",\n    response_type: "code",\n  })\n\n/**\n * Takes a token, and returns a new token with updated\n * `accessToken` and `accessTokenExpires`. If an error occurs,\n * returns the old token and an error property\n */\nasync function refreshAccessToken(token) {\n  try {\n    const url =\n      "https://oauth2.googleapis.com/token?" +\n      new URLSearchParams({\n        client_id: process.env.GOOGLE_CLIENT_ID,\n        client_secret: process.env.GOOGLE_CLIENT_SECRET,\n        grant_type: "refresh_token",\n        refresh_token: token.refreshToken,\n      })\n\n    const response = await fetch(url, {\n      headers: {\n        "Content-Type": "application/x-www-form-urlencoded",\n      },\n      method: "POST",\n    })\n\n    const refreshedTokens = await response.json()\n\n    if (!response.ok) {\n      throw refreshedTokens\n    }\n\n    return {\n      ...token,\n      accessToken: refreshedTokens.access_token,\n      accessTokenExpires: Date.now() + refreshedTokens.expires_in * 1000,\n      refreshToken: refreshedTokens.refresh_token ?? token.refreshToken, // Fall back to old refresh token\n    }\n  } catch (error) {\n    console.log(error)\n\n    return {\n      ...token,\n      error: "RefreshAccessTokenError",\n    }\n  }\n}\n\nexport default NextAuth({\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n      authorization: GOOGLE_AUTHORIZATION_URL,\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user, account }) {\n      // Initial sign in\n      if (account && user) {\n        return {\n          accessToken: account.access_token,\n          accessTokenExpires: Date.now() + account.expires_in * 1000,\n          refreshToken: account.refresh_token,\n          user,\n        }\n      }\n\n      // Return previous token if the access token has not expired yet\n      if (Date.now() < token.accessTokenExpires) {\n        return token\n      }\n\n      // Access token has expired, try to update it\n      return refreshAccessToken(token)\n    },\n    async session({ session, token }) {\n      session.user = token.user\n      session.accessToken = token.accessToken\n      session.error = token.error\n\n      return session\n    },\n  },\n})\n')),(0,s.kt)("h3",{id:"client-side"},"Client Side"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"RefreshAccessTokenError")," error that is caught in the ",(0,s.kt)("inlineCode",{parentName:"p"},"refreshAccessToken()")," method is passed all the way to the client. This means that you can direct the user to the sign in flow if we cannot refresh their token."),(0,s.kt)("p",null,"We can handle this functionality as a side effect:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="pages/home.js"',title:'"pages/home.js"'},'import { signIn, useSession } from "next-auth/react";\nimport { useEffect } from "react";\n\nconst HomePage() {\n  const { data: session } = useSession();\n\n  useEffect(() => {\n    if (session?.error === "RefreshAccessTokenError") {\n      signIn(); // Force sign in to hopefully resolve error\n    }\n  }, [session]);\n\nreturn (...)\n}\n')))}h.isMDXComponent=!0}}]);