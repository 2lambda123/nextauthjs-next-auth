import { Callout } from "nextra/components"
import { RichTabs } from "@/components/RichTabs"
import { Code } from "@/components/Code"
import { Screenshot } from "@/components/Screenshot"
import {
  SignIn,
  SignOut,
  UserCircle,
  HardDrives,
  IdentificationBadge,
  GitFork,
  PaintBucket,
} from "@phosphor-icons/react"

# Managing the user session

Auth.js ships with lightweight utilities to help you manage the user's session easily. Aside from [built-in pages](/tutorials/custom-pages/built-in-pages), which are [themable](/tutorials/theming) or [fully customisable](/tutorials/custom-pages/signin), Auth.js does not come with any built-in styles.

You're in charge of the building the UI for session management. Below we summarise some of the most common patterns for handling user sessions that you'll need to build before shipping your app to production.

<RichTabs defaultValue="login">
  <RichTabs.List className="gap-2">
    <RichTabs.Trigger value="login">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <SignIn fontSize="2.2rem" />
        <span>Handle sign in/out</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger value="user-menu">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <UserCircle fontSize="2.2rem" />
        <span>Display user menu</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger value="protecting">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <GitFork fontSize="2.2rem" />
        <span>Protecting routes</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger value="custom-pages">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <PaintBucket fontSize="2.2rem" />
        <span>Custom pages</span>
      </div>
    </RichTabs.Trigger>
  </RichTabs.List>

<RichTabs.Content className="p-8" value="login">

To signin your users, make sure you have at least one [authentication method](/getting-started/authentication) setup. You then need to build a button which will call the sign in function from your Auth.js framework package.

<Code>
  <Code.Next>

`next-auth` supports both server-side and client-side Signin and Signout methods.

#### Server-side

```tsx filename="./components/auth/sign-in.tsx"
import { signIn } from "../../auth.ts"

export function SignIn() {
  return (
    <form
      action={async () => {
        "use server"
        await signIn()
      }}
    >
      <button type="submit">Sign in</button>
    </form>
  )
}
```

#### Client-side

```tsx filename="app/client/page.tsx"
"use client"

import { signIn } from "next-auth/react"

export default function Client() {
  return (
    <nav>
      <button onClick={() => signIn("github")}>Sign in Github</button>
    </nav>
  )
}
```

  </Code.Next>
  <Code.NextPages>

```tsx filename="src/components/signin-button.tsx"
import { signIn } from "next-auth/react"

export function SignIn() {
  return <Button onClick={() => signIn()}>Sign In</Button>
}
```

  </Code.NextPages>
  <Code.Svelte>

The SvelteKit client also supports two signin / signout methods, one server-side using Form Actions, and one client-side using normal requests and redirects.

### Handling Signin

#### Form Action (Server-Side)

To signin your users using a SvelteKit form action, we can use the `SignIn` component exported from `@auth/sveltekit/components`.

```svelte filename="src/routes/+page.svelte"
<script lang="ts">
  import { SignIn } from "@auth/sveltekit/components"
</script>

<header>
  <nav>
    <SignIn>
      <span slot="submitButton">Sign In with GitHub</span>
    </SignIn>
  </nav>
</header>
```

This requires a server action at `/signin`, this path can be customized with the `signInPage` prop.

```ts filename="src/routes/signin/+page.server.ts"
import { signIn } from "../../auth"
import type { Actions } from "./$types"

export const actions: Actions = { default: signIn }
```

#### Client Side

Client-side is a bit simpler as we just need to import a button `on:click` handler from `@auth/sveltekit/client`.

```svelte filename="src/routes/+page.svelte"
<script lang="ts">
  import { signIn } from '@auth/sveltekit/client'
</script>

<div>
  <nav>
    <img src="/img/logo.svg" alt="Company Logo" />
    <button on:click={signIn}>Signin</button>
  </nav>
</div>
```

Just like in other frameworks, you can also pass a provider to the `signIn` function which will attempt to login directly with that provider.

  </Code.Svelte>
</Code>

When clicking this button in your application, the user will be redirected to the configured sign in page. If you did not setup a [custom sign in page](/guides/custom-pages/signin), the user will be redirected to `/api/auth/signin`, the sign in page Auth.js ships with. There the configured authentication methods will be displayed:

import DefaultSignInPage from "../../public/img/getting-started/default-signin-page.webp"

<Screenshot src={DefaultSignInPage} alt="Default Sign-in Page" />

Once authenticated, the user will be redirected back to the page they started the signin from. If
you want the user to be redirected somewhere else after sign in (.i.e `/dashboard`), you can do so
by passing the target URL as `redirectTo` in the sign-in options.

<Code>
<Code.Next>

```tsx filename="app/components/signin-button.tsx"
import { signIn } from "../../auth.ts"

export function SignIn() {
  return (
    <form
      action={async () => {
        "use server"
        await signIn("github", { redirectTo: "/dashboard" })
      }}
    >
      <button type="submit">Sign in</button>
    </form>
  )
}
```

</Code.Next>
<Code.NextPages>

```tsx filename="src/components/signin-button.tsx"
import { signIn } from "next-auth/react"

export function SignIn() {
  return (
    <Button onClick={() => signIn("github", { redirectTo: "/dashboard" })}>
      Sign In
    </Button>
  )
}
```

</Code.NextPages>
<Code.Svelte>

```svelte filename="src/routes/+page.svelte"
<script lang="ts">
  import { page } from "$app/stores"
  import { SignIn } from "@auth/sveltekit/components"
</script>

<header>
  <nav>
    <SignIn
      signInPage="signin"
      options={{
        redirectTo: $page.data.redirectTo
          ? `/${decodeURIComponent($page.data.redirectTo).slice(1)}`
          : `/dashboard`,
      }}
      className="w-full"
    >
      <span slot="submitButton">Sign in</span>
    </SignIn>
  </nav>
</header>
```

</Code.Svelte>
</Code>

### Handling Signout

Handling sign out can be done similarly to signing in. Most frameworks offer both a client-side and server-side method for signing out as well.

<Code>
<Code.Next>

#### Server-side

To sign out users with a form action, you can build a button that calls the exported sign-out function from your Auth.js config.

```tsx filename="app/components/signout-button.tsx" {6}
import { signOut } from "../../auth.ts"

export function SignOut() {
  return (
    <form
      action={async () => {
        "use server"
        await signOut()
      }}
    >
      <button type="submit">Sign Out</button>
    </form>
  )
}
```

#### Client-side

Alternatively, you can use the client-side methods from `next-auth/react` to sign out as well.

```ts filename="app/client/page.tsx"
"use client"

import { signOut } from "next-auth/react"

export default function Client() {
  return (
    <nav className="card">
      <div className="btn-wrapper">
        <button onClick={() => signOut()}>Sign out</button>
      </div>
    </nav>
  )
}
```

</Code.Next>
<Code.NextPages>

```tsx filename="src/components/signout-button.tsx"
import { signOut } from "next-auth/react"

export function SignOut() {
  return (
    <button onClick={() => signOut()}
      Sign Out
    </button>
  )
}
```

</Code.NextPages>
<Code.Svelte>

SvelteKit supports both server and client-side methods for signing out as well.

#### Server-side

```svelte filename="src/routes/+page.svelte"
<script lang="ts">
  import { SignOut } from "@auth/sveltekit/components"
</script>

<header>
  <nav>
    <SignOut>
      <span slot="submitButton">Signout</span>
    </SignIn>
  </nav>
</header>
```

This requires a server action at `/signout`, this path can be customized with the `signOutPage` prop.

```ts filename="src/routes/signout/+page.server.ts"
import { signOut } from "../../auth"
import type { Actions } from "./$types"

export const actions: Actions = { default: signOut }
```

#### Client Side

Client-side is a bit simpler as we just need to import a button `on:click` handler from `@auth/sveltekit/client`.

```svelte filename="src/routes/+page.svelte"
<script lang="ts">
  import { signOut } from '@auth/sveltekit/client'
</script>

<div>
  <nav>
    <img src="/img/logo.svg" alt="Company Logo" />
    <button on:click={signOut}>Signin</button>
  </nav>
</div>
```

</Code.Svelte>
</Code>

<Callout>
  Note that when signing out of an OAuth provider like GitHub in an Auth.js
  application, the user will not be signed out of GitHub elsewhere.
</Callout>

</RichTabs.Content>

<RichTabs.Content className="p-8" value="user-menu">

Once a user is logged in, you often want to show their profile picture or display some other user information. To do this, we'll have to fetch the session in our pages or components.

In Auth.js we need to call the `auth()` helper which will return the session data. Be aware, this is an async function that needs to be awaited. That means you'll need to use it in an `async` component (i.e. a React Server Component) or in a `useEffect` hook, for example.

<Code>
<Code.Next>

```tsx filename="./components/UserAvatar"
import { auth } from "../auth"

export default async function UserAvatar() {
  const session = await auth()

  if (!session.user) return null

  return (
    <div>
      <img src={session.user.img} alt="User Avatar" />
    </div>
  )
}
```

</Code.Next>
<Code.NextPages>

In the pages router, you'll need to access the `session` in the page itself and then, for example, pass it on to your `UserAvatar` component.

```tsx filename="./components/UserAvatar"
export function UserAvatar({ session }) {
  return (
    <div>
      <img
        src={session?.user.img ?? "https://source.boringavatars.com/marble/120"}
        alt="User Avatar"
      />
    </div>
  )
}
```

Next, we'll need to setup the pages. We can access the `session` server side or client side in the page.

### Page Server Side

```tsx filename="./pages/dashboard.tsx"
import { auth } from "@/auth.ts"
import { UserAvatar } from "@/components/UserAvatar"

export default function Dashboard({ session }) {
  return (
    <nav>
      <UserAvatar session={session} />
    </nav>
  )
}

export async function getServerSideProps(ctx) {
  const session = await auth(ctx)

  return {
    props: {
      session,
    },
  }
}
```

### Page Client Side

When accessing the session client-side using `useSession()`, make sure an Auth.js `<SessionProvider />` is
wrapping your page.

```tsx filename="pages/_app.tsx"
import type { AppProps } from "next/app"
import { SessionProvider } from "next-auth/react"

export default function MyApp({
  Component,
  pageProps: { session, ...pageProps },
}: AppProps) {
  return (
    <SessionProvider session={session}>
      <Component {...pageProps} />;
    </SessionProvider>
  )
}
```

```tsx filename="pages/dashboard.tsx
import { useSession } from "next-auth/react"
import { UserAvatar } from "@/components/UserAvatar"

export default function Dashboard() {
  const session = useSession()

  return (
    <nav>
      <UserAvatar session={session} />
    </nav>
  )
}
```

</Code.NextPages>
<Code.Svelte>

With SvelteKit, ensure you're returning the `session` from the load function in your page or layout server file. You can then access the session and user data on the `$page.data.session` object.

```svelte filename="src/routes/+page.server.ts"
import type { PageServerLoad } from "./$types"

export const load: PageServerLoad = async (events) => {
  const session = await events.locals.auth()

  if (!session?.user?.userId) {
    redirect(303, `/login`)
  }

  return {
    session
  }
}
```

```svelte filename="src/components/user-avatar.svelte"
<script lang="ts">
  import { page } from "$app/stores"
</script>

<img
  src={$page.data.session?.user?.image ?? 'https://source.boringavatars.com/marble/120/'}
  alt="User Avatar"
/>
```

</Code.Svelte>
</Code>

</RichTabs.Content>

<RichTabs.Content className="p-8" value="protecting">

Protecting routes can be done generally by checking for the session and taking an action if an active session is not found, like redirecting the user to the login page or simply returning a `401: Unauthenticated` response.

### Pages

<Code>
<Code.Next>

Protecting pages comes in two forms: server-side and client-side. For server-side protection, you can use the `auth` export from the Auth.js configuration file directly. Client-side we can use the `useSession` hook.

In a client component, we can use the `useSession` import from `next-auth/react`.

```tsx filename="app/client/page.tsx" {6-7}
"use client"

import { useSession } from "next-auth/react"

export default function Client() {
  const { data: session, session } = useSession()
  if (session.status === "unauthenticated") return <div>Not authenticated</div>

  return (
    <div>
      <pre>{JSON.stringify(session, null, 2)}</pre>
    </div>
  )
}
```

In a server component, we can use `auth` directly.

```tsx filename="app/server/page.tsx" {4-5}
import { auth } from "auth"

export default async function Page() {
  const session = await auth()
  if (!session) return <div>Not authenticated</div>

  return (
    <div>
      <pre>{JSON.stringify(session, null, 2)}</pre>
    </div>
  )
}
```

</Code.Next>
<Code.NextPages>

To protect a page in the Next.js Pages router, we can use `auth` in `getServerSideProps`.

```tsx filename="./pages/dashboard.tsx" {4, 10}
import { auth } from "../auth"

export default function Dashboard({ session }) {
  if (!session.user) return <div>Not authenticated</div>

  return <div>{JSON.stringify(session, null, 2)}</div>
}

export async function getServerSideProps(ctx) {
  const session = await auth(ctx)

  return {
    props: {
      session,
    },
  }
}
```

To access the session client-side using `useSession()`. Make sure `<SessionProvider />` is
wrapping your application.

```tsx filename="./pages/_app.tsx"
import type { AppProps } from "next/app"
import { SessionProvider } from "next-auth/react"

export default function MyApp({
  Component,
  pageProps: { session, ...pageProps },
}: AppProps) {
  return (
    <SessionProvider session={session}>
      <Component {...pageProps} />;
    </SessionProvider>
  )
}
```

</Code.NextPages>
<Code.Svelte>

In SvelteKit, you can leverage the `event.locals.auth()` function that is put there by the Auth.js `handle` we're using in our `hooks.server.ts`. Using this server-side, we can check for the session in any `+page.server.ts` or `+layout.server.ts` and either allow the request on, or redirect to the `/login` page, for example.

```ts filename="src/routes/dashboard/+page.server.ts" {5, 8}
import { fail, redirect } from "@sveltejs/kit"
import type { PageServerLoad } from "./$types"

export const load: PageServerLoad = async (event) => {
  const session = await event.locals.auth()

  if (!session?.user?.userId) {
    // const fromUrl = url.pathname + url.search
    // redirect(303, `/login?redirectTo=${encodeURIComponent(fromUrl)}`)
    return fail(401, { type: "error", error: "Unauthenticated" })
  }

  return {
    session,
  }
}
```

</Code.Svelte>
</Code>

### API Routes

Protecting API routes in the various frameworks can also be done with the `auth` export.

<Code>
<Code.Next>

```ts filename="./app/api/admin/route.ts" {1,5}
import { auth } from "auth"
import { NextResponse } from "next/server"

export const GET = auth(function GET(req) {
  if (req.auth) return NextResponse.json(req.auth)
  return NextResponse.json({ message: "Not authenticated" }, { status: 401 })
})
```

</Code.Next>
<Code.NextPages>

```ts filename="./pages/api/admin.ts"
// TODO: Update once server-side API methods are implemented for pages router again

// import { auth } from "../../auth"
// import { getSession } from "next-auth/react"
import { NextApiRequest, NextApiResponse } from "next"

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // const session = await auth(req, res)
  // const session = await getSession(req, res)
  const url = `${req.headers["x-forwarded-proto"]}://${req.headers.host}/api/auth/session`

  const sessionRes = await fetch(url)
  const session = await sessionRes.json()

  if (!session.user) {
    return res.status(401).json({ message: "Not authenticated" })
  }

  return res.json({ data: "Protected data" })
}
```

</Code.NextPages>
<Code.Svelte>

```ts filename="src/routes/api/users/+server.ts" {5}
import type { RequestHandler } from "./$types"

export const GET: RequestHandler = async (event) => {
  const session = await event.locals.auth()

  if (!session?.user?.userId) {
    return new Response(null, { status: 401, statusText: "Unauthorized" })
  }
}
```

</Code.Svelte>
</Code>

### Next.js Middleware

With Next.js 12+, the easiest way to protect a set of pages is using the middleware file. You can create a `middleware.ts` file in your root pages directory with the following contents.

```ts filename="middleware.ts"
import { auth } from "./auth"

export default auth((req) => {
  if (!req.auth) {
    return NextResponse.redirect("/login")
  }
})

export const config = { matcher: ["/admin"] }
```

This will protect all routes under `/admin`.

You can also use a regex to match multiple routes or you can negate certain routes in order to protect all remaining routes. The following example avoids running the middleware on paths such as the favicon or static images.

```ts filename="middleware.ts"
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
}
```

Middleware will protect pages as defined by the `matcher` config export. For more details about the matcher, check out the [Next.js docs](https://nextjs.org/docs/pages/building-your-application/routing/middleware#matching-paths).

</RichTabs.Content>

<RichTabs.Content className="p-8" value="custom-pages">

### Custom Pages

To enable custom pages add the following to your Auth.js configuration. In the `pages` object, the key is the type of page and the value is the path/route at which the page is located. Please make sure you actually have a page at the specified route.

<Code>
<Code.Next>

```ts filename="./auth.ts" {8-10}
import { NextAuth } from "next-auth"
import Github from "next-auth/providers/github"

// Define your configuration in a separate variable and pass it to NextAuth()
// This way we can also 'export const config' for use later
export const config = {
  providers: [Github],
  pages: {
    signin: "/login",
  },
}

export const { signIn, signOut, handle } = NextAuth(config)
```

</Code.Next>
<Code.Svelte>

```ts filename="src/auth.ts" {14-16}
import SvelteKitAuth from "@auth/sveltekit"
import GitHub from "@auth/sveltekit/providers/github"
import type { Provider } from "@auth/sveltekit/providers"

const providers: Provider[] = [Github]

// Export this map of provider details to use in the sign-in page later
export const providerMap = providers.map((provider) => {
  return { id: provider.id, name: provider.name }
})

export const { handle, signIn, signOut } = SvelteKitAuth({
  providers,
  pages: {
    signIn: "/signin",
  },
})
```

```ts filename="src/hooks.server.ts"
export { handle } from "./auth"
```

</Code.Svelte>
</Code>

To continue setting up the custom page, checkout our [guide on custom pages](/guides/custom-pages/signin).

</RichTabs.Content>
</RichTabs>
