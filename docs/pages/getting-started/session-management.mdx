import { Callout } from "nextra/components"
import { RichTabs } from "@/components/RichTabs"
import { Code } from "@/components/Code"
import { Screenshot } from "@/components/Screenshot"
import {
  SignIn,
  SignOut,
  UserCircle,
  HardDrives,
  IdentificationBadge,
  GitFork,
  PaintBucket,
} from "@phosphor-icons/react"

# Managing the user session

Auth.js ships with lightweight utilities to help you manage the user's session easily. Aside from [built-in pages](/tutorials/custom-pages/built-in-pages), which are [themable](/tutorials/theming) or [fully customisable](/tutorials/custom-pages/signin), Auth.js does not come with any built-in styles.

You're in charge of the building the UI for session management. Below we summarise some of the most common patterns for handling user sessions that you'll need to build before shipping your app to production.

<RichTabs defaultValue="login">
  <RichTabs.List className="gap-2">
    <RichTabs.Trigger value="login">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <SignIn fontSize="2.2rem" />
        <span>Handle sign in/out</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger value="user-menu">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <UserCircle fontSize="2.2rem" />
        <span>Display user menu</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger value="protecting">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <GitFork fontSize="2.2rem" />
        <span>Protecting routes</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger value="custom-pages">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <PaintBucket fontSize="2.2rem" />
        <span>Custom pages</span>
      </div>
    </RichTabs.Trigger>
  </RichTabs.List>

<RichTabs.Content className="p-8" value="login">

For signing in users, assuming you have [already setup an authentication method](/getting-started/authentication), you only need to build a button that when pressed calls the `signIn` function exported in your Auth.js config:

<Code>
  <Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"

export const { signIn, auth } = NextAuth({
  providers: [GitHub],
})
```

```tsx filename="./components/auth/sign-in.tsx"
import { signIn } from "../../auth.ts"

export function SignIn() {
  return (
    <form
      action={async () => {
        "use server"
        await signIn()
      }}
    >
      <button type="submit">Sign in</button>
    </form>
  )
}
```

  </Code.Next>
  <Code.Svelte>

```svelte filename="src/routes/+page.svelte"
<script lang="ts">
  import { page } from "$app/stores"
  import { SignIn } from "@auth/sveltekit/components"
</script>

<header>
  <nav>
    <SignIn>
      <span slot="submitButton">Sign In with GitHub</span>
    </SignIn>
  </nav>
</header>
```

  </Code.Svelte>
</Code>

When clicking this button in your application, the user will be redirected to the configured sign in page. If you did not setup a [custom sign in page](/tutorials/custom-pages/signin), the user will be redirected to `/api/auth/signin`, the sign in page Auth.js ships with. There the configured authentication methods will be displayed:

import DefaultSignInPage from "../../public/img/getting-started/default-signin-page.webp"

<Screenshot src={DefaultSignInPage} alt="Default Sign-in Page" />

Once authenticated, the user will be redirected back to the page they started the signin from. If
you want the user to be redirected somewhere else after sign in (.i.e `/dashboard`), you can do so
by passing the target URL as `redirectTo` in the sign-in options.

<Code>
<Code.Next>

```tsx filename="app/components/signin-button.tsx"
import { signIn } from "../../auth.ts"

export function SignIn() {
  return (
    <form
      action={async () => {
        "use server"
        await signIn("github", { redirectTo: "/dashboard" })
      }}
    >
      <button type="submit">Sign in</button>
    </form>
  )
}
```

</Code.Next>
<Code.Svelte>

```svelte filename="src/routes/+page.svelte"
<script lang="ts">
  import { page } from "$app/stores"
  import { SignIn } from "@auth/sveltekit/components"
</script>

<header>
  <nav>
    <SignIn
      signInPage="signin"
      options={{
        redirectTo: $page.data.redirectTo
          ? `/${decodeURIComponent($page.data.redirectTo).slice(1)}`
          : `/dashboard`,
      }}
      className="w-full"
    >
      <span slot="submitButton">Sign in</span>
    </SignIn>
  </nav>
</header>
```

</Code.Svelte>
</Code>

### Handling sign out

To sign out users, you can build a button that calls the exported sign-out function from your Auth.js config when clicked.

<Code>
<Code.Next>

```tsx filename="app/components/signout-button.tsx" {6}
import { signOut } from "../../auth.ts"

export function SignOut() {
  return (
    <form
      action={async () => {
        "use server"
        await signOut()
      }}
    >
      <button type="submit">Sign Out</button>
    </form>
  )
}
```

</Code.Next>
<Code.Svelte>

```svelte filename="src/routes/+page.svelte"
<script lang="ts">
  import { page } from "$app/stores"
  import { SignOut } from "@auth/sveltekit/components"
</script>

<header>
  <nav>
    <SignOut>
      <span slot="submitButton">Signout</span>
    </SignIn>
  </nav>
</header>
```

</Code.Svelte>
</Code>

</RichTabs.Content>

<RichTabs.Content className="p-8" value="user-menu">

A common use-case once a user is logged in, is that you might want to display some session information by displaying the user's name and profile picture.

In Auth.js we need to call the `auth()` helper exported from the Auth.js configuration file to get the available user session.

<Code>
<Code.Next>

```tsx filename="./components/UserAvatar"
import { auth } from "../auth"

export function UserAvatar() {
  const session = await auth()

  if (!session.user) return null

  return (
    <div>
      <img
        src={session?.user.img ?? "https://source.boringavatars.com/marble/120"}
        alt="User Avatar"
      />
    </div>
  )
}
```

</Code.Next>
<Code.NextPages>

In the pages router, you'll need to access the `session` in the page itself and then pass it into your `UserAvatar` component.

```tsx filename="./components/UserAvatar"
export function UserAvatar({ session }) {
  return (
    <div>
      <img
        src={session?.user.img ?? "https://source.boringavatars.com/marble/120"}
        alt="User Avatar"
      />
    </div>
  )
}
```

Next, we'll need to setup the pages. We can access the `session` server side or client side in the page.

### Page Server Side

```tsx filename="./pages/dashboard.tsx"
import { auth } from "@/auth.ts"
import { UserAvatar } from "@/components/UserAvatar"

export default function Dashboard({ session }) {
  return (
    <nav>
      <UserAvatar session={session} />
    </nav>
  )
}

export async function getServerSideProps(ctx) {
  const session = await auth(ctx)

  return {
    props: {
      session,
    },
  }
}
```

### Page Client Side

When accessing the session client-side using `useSession()`, make sure an Auth.js `<SessionProvider />` is
wrapping your page.

```tsx filename="pages/_app.tsx"
import type { AppProps } from "next/app"
import { SessionProvider } from "next-auth/react"

export default function MyApp({
  Component,
  pageProps: { session, ...pageProps },
}: AppProps) {
  return (
    <SessionProvider session={session}>
      <Component {...pageProps} />;
    </SessionProvider>
  )
}
```

```tsx filename="pages/dashboard.tsx
import { useSession } from "next-auth/react"
import { UserAvatar } from "@/components/UserAvatar"

export default function Dashboard() {
  const session = useSession()

  return (
    <nav>
      <UserAvatar session={session} />
    </nav>
  )
}
```

</Code.NextPages>
<Code.Svelte>

```svelte filename="src/components/user-avatar.svelte"
<script lang="ts">
  import { page } from "$app/stores"
</script>

<img
  src={$page.data.session?.user?.image ?? 'https://source.boringavatars.com/marble/120/'}
  alt="User Avatar"
/>
```

</Code.Svelte>
</Code>

</RichTabs.Content>

<RichTabs.Content className="p-8" value="protecting">

Protecting routes can be done generally by checking for the session and taking an action if an active session is not found, like redirecting the user to the login page or simply returning a `401: Unauthenticated` response.

### Pages

<Code>
<Code.Next>

Protecting pages comes in two forms: server-side and client-side. For server-side protection, you can use the `auth` export from the Auth.js configuration file directly. Client-side we can use the `useSession` hook.

In a client component, we can use the `useSession` import from `next-auth/react`.

```tsx filename="app/client/page.tsx" {6-7}
"use client"

import { useSession } from "next-auth/react"

export default function Client() {
  const { data: session, session } = useSession()
  if (session.status === "unauthenticated") return <div>Not authenticated</div>

  return (
    <div>
      <pre>{JSON.stringify(session, null, 2)}</pre>
    </div>
  )
}
```

In a server component, we can use `auth` directly.

```tsx filename="app/server/page.tsx" {4-5}
import { auth } from "auth"

export default async function Page() {
  const session = await auth()
  if (!session) return <div>Not authenticated</div>

  return (
    <div>
      <pre>{JSON.stringify(session, null, 2)}</pre>
    </div>
  )
}
```

</Code.Next>
<Code.NextPages>

To protect a page in the Next.js Pages router, we can use `auth` in `getServerSideProps`.

```tsx filename="./pages/dashboard.tsx" {4, 10}
import { auth } from "../auth"

export default function Dashboard({ session }) {
  if (!session.user) return <div>Not authenticated</div>

  return <div>{JSON.stringify(session, null, 2)}</div>
}

export async function getServerSideProps(ctx) {
  const session = await auth(ctx)

  return {
    props: {
      session,
    },
  }
}
```

To access the session client-side using `useSession()`. Make sure `<SessionProvider />` is
wrapping your application.

```tsx filename="./pages/_app.tsx"
import type { AppProps } from "next/app"
import { SessionProvider } from "next-auth/react"

export default function MyApp({
  Component,
  pageProps: { session, ...pageProps },
}: AppProps) {
  return (
    <SessionProvider session={session}>
      <Component {...pageProps} />;
    </SessionProvider>
  )
}
```

</Code.NextPages>
<Code.Svelte>

```ts filename="src/routes/dashboard/+page.server.ts" {5, 8}
import { fail, redirect } from "@sveltejs/kit"
import type { PageServerLoad } from "./$types"

export const load: PageServerLoad = async ({ locals, url }) => {
  const session = await locals?.auth()

  if (!session?.user?.userId) {
    return fail(401, { type: "error", error: "Unauthenticated" })
  }
}
```

</Code.Svelte>
</Code>

### API Routes

Protecting API routes in the various frameworks can also be done with the `auth` export.

<Code>
<Code.Next>

```ts filename="./app/api/admin/route.ts" {1,5}
import { auth } from "auth"
import { NextResponse } from "next/server"

export const GET = auth(function GET(req) {
  if (req.auth) return NextResponse.json(req.auth)
  return NextResponse.json({ message: "Not authenticated" }, { status: 401 })
})
```

</Code.Next>
<Code.NextPages>

```ts filename="./pages/api/admin.ts"
// TODO: Update once server-side API methods are implemented for pages router again

// import { auth } from "../../auth"
// import { getSession } from "next-auth/react"
import { NextApiRequest, NextApiResponse } from "next"

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // const session = await auth(req, res)
  // const session = await getSession(req, res)
  const url = `${req.headers["x-forwarded-proto"]}://${req.headers.host}/api/auth/session`

  const sessionRes = await fetch(url)
  const session = await sessionRes.json()

  if (!session.user) {
    return res.status(401).json({ message: "Not authenticated" })
  }

  return res.json({ data: "Protected data" })
}
```

</Code.NextPages>
<Code.Svelte>

```ts filename="src/routes/api/users/+server.ts" {5}
import type { RequestHandler } from "./$types"
import { json, fail } from "@sveltejs/kit"

export const GET: RequestHandler = async ({ url, locals }) => {
  const session = await locals.auth()
  if (!session?.user?.userId) {
    return fail(401, { type: "error", error: "Unauthenticated" })
  }
}
```

</Code.Svelte>
</Code>

### Next.js Middleware

With Next.js 12+, the easiest way to protect a set of pages is using the middleware file. You can create a `middleware.ts` file in your root pages directory with the following contents.

```ts filename="middleware.ts"
import { auth } from "./auth"

export default auth((req) => {
  if (!req.auth) {
    return NextResponse.redirect("/login")
  }
})

export const config = { matcher: ["/admin"] }
```

This will protect all routes under `/admin`.

You can also use a regex to match multiple routes or you can negate certain routes in order to protect all remaining routes. The following example avoids running the middleware on paths such as the favicon or static images.

```ts filename="middleware.ts"
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
}
```

Middleware will protect pages as defined by the `matcher` config export. For more details about the matcher, check out the [Next.js docs](https://nextjs.org/docs/pages/building-your-application/routing/middleware#matching-paths).

</RichTabs.Content>

<RichTabs.Content className="p-8" value="custom-pages">

### Custom Pages

To enable custom pages add the following to your Auth.js configuration. In the `pages` object, the key is the type of page and the value is the path/route at which the page is located. Please make sure you actually have a page at the specified route.

<Code>
<Code.Next>

```ts filename="./auth.ts" {8-10}
import { NextAuth } from "next-auth"
import Github from "next-auth/providers/github"

// Define your configuration in a separate variable and pass it to NextAuth()
// This way we can also 'export const config' for use later
export const config = {
  providers: [Github],
  pages: {
    signin: "/login",
  },
}

export const { signIn, signOut, handle } = NextAuth(config)
```

</Code.Next>
<Code.Svelte>

```ts filename="src/auth.ts" {14-16}
import SvelteKitAuth from "@auth/sveltekit"
import GitHub from "@auth/sveltekit/providers/github"
import type { Provider } from "@auth/sveltekit/providers"

const providers: Provider[] = [Github]

// Export this map of provider details to use in the sign-in page later
export const providerMap = providers.map((provider) => {
  return { id: provider.id, name: provider.name }
})

export const { handlers, auth, signIn, signOut } = SvelteKitAuth({
  providers,
  pages: {
    signIn: "/signin",
  },
})
```

</Code.Svelte>
</Code>

To continue setting up the custom page, checkout our [guide on custom pages](/guides/custom-pages/signin).

</RichTabs.Content>
</RichTabs>
