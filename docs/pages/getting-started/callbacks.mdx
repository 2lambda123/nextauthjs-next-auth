import { Callout } from "nextra/components"

# Callbacks

The general shape of the callbacks are as follows.

```ts
callbacks: {
  async signIn({ user, account, profile, email, credentials }) {
    return true
  },
  async redirect({ url, baseUrl }) {
    return baseUrl
  },
  async session({ session, user, token, trigger }) {
    return session
  },
  async jwt({ token, user, account, profile, trigger, isNewUser, session }) {
    return token
  }
}
```

## `jwt`

This callback is called whenever a JSON Web Token is about to be created (i.e. at sign in) or updated (i.e whenever a session is accessed in the client). Anything you return here will be saved in the JWT and forwarded to the `session` callback. There you can control what should be returned to the client. Anything else will be kept from your front-end. The JWT is encrypted by default via your `AUTH_SECRET` environment variable.

For example, you can use this callback to persist the OAuth `access_token` to the JWT.

```ts filename="auth.ts"
callbacks: {
  async jwt({ token, account }) {
    if (account) {
      token.accessToken = account.access_token
    }
    return token
  }
}
```

<Callout>
  Use an `if` branch to check for the existence of parameters (apart from
  token). If they exist, this means that the callback is being invoked for the
  first time (i.e. the user is being "registered"). This is a good place to
  persist additional data like an `access_token` in the JWT. **Subsequent
  invocations will only contain the token parameter**.
</Callout>

For more details on the arguments available, check out the [API Reference documentation](#TODO) for this callback.

## `session`

This callback is called whenever a session is checked. (Eg.: invoking the `/api/session` endpoint, using `useSession` or `getSession`). The return value will be exposed to the client, so be careful what you return here. If you want to make something available you added to the token through the `jwt` callback, you have to explicitly forward it here to make it available to the client.

<Callout>
  By default, only a subset (email, name, image) of the token is returned for
  increased security.
</Callout>

The `token` argument is only available when using the `jwt` session strategy, and the `user` argument is only available when using the `database` session strategy.

```ts filename="auth.ts"
callbacks: {
  async session({ session, token, user }) {
    // Send properties to the client, like an access_token from a provider.
    session.accessToken = token.accessToken

    return session
  }
}
```

<Callout type="warning">
The session object is not persisted server side, even when using database sessions - only data such as the session token (id), the user, and the expiry time is stored in the session table.

If you need to persist session data server side, you must save it elsewhere and use the `accessToken` from session as a lookup key. You can connect to the database in the `session()` callback to retrieve this information. Session `accessToken` values do not rotate and are valid as long as the session is valid.

If you are using JSON Web Tokens instead of database sessions, you should use the User ID or another unique key stored in the token as the look up to such data.

</Callout>

## `redirect`

This callback is called anytime the user is redirected to a callback URL (e.g. on signin or signout). By default only URLs on the same host as the site are allowed, you can use this callback to customise that behaviour.

```ts filename="auth.ts"
callbacks: {
  async redirect({ url, baseUrl }) {
    // Allows relative callback URLs
    if (url.startsWith("/")) return `${baseUrl}${url}`
    // Allows callback URLs on the same origin
    else if (new URL(url).origin === baseUrl) return url
    return baseUrl
  }
}
```

## `signIn`

Controls whether a user is allowed to sign in or not. Returning `true` continues the sign-in flow. Returning `false` or throwing an error will stop the sign-in flow and redirect the user to the error page. Returning a string will redirect the user to the specified URL.

Unhandled errors will throw an `AuthorizedCallbackError` with the message set to the original error.

```ts filename="auth.ts"
callbacks: {
  async signIn({ profile }) {
    // Only allow sign in for users with email addresses ending with "yourdomain.com"
    return profile?.email?.endsWith("@yourdomain.com")
  }
}
```
