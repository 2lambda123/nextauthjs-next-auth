import { Steps, Callout, Tabs } from "nextra/components"
import { Link } from "@/components/Link"
import { SelectProvider } from "@/components/SelectProvider"
import { RichTabs } from "@/components/RichTabs"
import { Code } from "@/components/Code"
import { Screenshot } from "@/components/Screenshot"
import { TokenAuthInstructions } from "@/components/TokenAuthInstructions"
import { GitDiff, Password, ChatDots, Fingerprint } from "@phosphor-icons/react"
import { ListDisclosure } from "@/components/ListDisclosure"
import manifest from "@/data/manifest.json"

# Authentication

At this point, you need to decide how you're gonna authenticate users in your application. Auth.js supports three main authentication paradigms.

- [OAuth authentication](/getting-started/providers/oauth-tutorial) (_Sign in with Google, Github, LinkedIn, etc..._)
- [Magic Links](/getting-started/providers/email-tutorial) (_Email Provider like Resend, Sendgrid, Nodemailer..._)
- [Credentials](/getting-started/providers/credentials-tutorial) (_Integrating with external APIs, etc..._)

<br />

<details>
<summary>
<b>Why does Auth.js recommend OAuth as the primary authentication method for your application?</b>
</summary>

OAuth providers spend significant amounts of money, time, and engineering effort to build abuse detection (_bot-protection, rate-limiting_), password management (_password reset, credential stuffing, rotation_), data security (_encryption/salting, strength validation_), and much more. It is likely that your application would benefit from leveraging these battle-tested solutions rather than try to rebuild them from scratch.

</details>
<details>
<summary>
<b>Do I need a database?</b>
</summary>

Auth.js by default uses [JSON Web Tokens](https://jwt.io/) for saving the user's session so you don't need to setup a database for authenticating users (_all of our JWT tokens are encrypted by default with `A256CBC-HS512`_). However, if you want to set up a database, you can use one of our official database adapters or create your own. The database will be used to persist the user's session. You can also force saving the users session in a JWT still when using a database adapter through the configuration options.

</details>
<details>
<summary>
<b>Can I set up more than one authentication method?</b>
</summary>

You can setup as many authentication methods as you'd like. But keep in mind, OAuth providers like Google and GitHub spend significant amounts of time, money, and engineering effort to build features such as abuse detection (_bot-protection, rate-limiting_), password management (_password reset, credential stuffing, rotation_), data security (_encryption/salting, strength validation_), and much more. It is likely that your application would benefit from leveraging these battle-tested solutions rather than try to rebuild them from scratch.

However, if you have multiple providers setup Auth.js will attempt to link a user's multiple accounts from the various providers under certain circumstances. For example, if a user has already signed in with GitHub, and therefore has a `User` and `Account` table entry associated with that Email, and they then attempt to signin with an email provider / magic link using the same email address, then Auth.js will link the two accounts based upon the matching email address. See the [FAQ](/concepts/faq#security) for more information on account linking.

</details>

Once you have decided how to authenticate users in your application (you can always add more authentication methods later), click on the instructions below for the initial setup.

<RichTabs defaultValue="oauth">
  <RichTabs.List className="gap-2">
    <RichTabs.Trigger key="oauth" value="oauth">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <GitDiff fontSize="2.5rem" />
        <span>Setup OAuth</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger key="token-auth" value="magic-link">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <ChatDots fontSize="2.5rem" />
        <span>Magic Link</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger key="external-auth" value="credentials">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <Password fontSize="2.5rem" />
        <span>Setup Credentials</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger key="webauthn" value="webauthn">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <Fingerprint fontSize="2.5rem" />
        <span>WebAuthn</span>
      </div>
    </RichTabs.Trigger>
  </RichTabs.List>
  <RichTabs.Content className="p-8" key="oauth" value="oauth">
    <SelectProvider />
  </RichTabs.Content>

<RichTabs.Content className="p-8" key="magic-link" value="magic-link">
  <TokenAuthInstructions />
</RichTabs.Content>

<RichTabs.Content className="p-8" key="webauthn" value="webauthn">
  <Callout type="warning">
    The WebAuthn / Passkeys provider is experimental and not recommended for
    production use.
  </Callout>
  The WebAuthn provider requires changes to all of the framework integration as well as any database adapter that plans to support it. Therefore, the WebAuthn provider is currently only supported in the following framework integration and database adapters. Support for more frameworks and adapters are coming soon.
- `next-auth@5.0.0-beta.8` or above
- `@auth/prisma-adapter@1.3.0` or above

<Steps>

### Install peer dependencies

```bash npm2yarn
npm install @simplewebauthn/browser @simplewebauthn/server
```

The `@simplewebauthn/browser` peer dependency is only required for custom signin pages. If you're using the Auth.js default pages, you can skip installing that peer dependency.

### Apply the required schema Migrations

This is the raw SQL migration, for more details including an example MongoDB migration, check out the Prisma `schema.prisma` [here](https://github.com/Maronato/next-auth/blob/main/packages/adapter-prisma/prisma/schema.prisma), or the PR adding support to Prisma [here](https://github.com/nextauthjs/next-auth/pull/9876).

In short, the Passkeys provider requires an additional table called `Authenticator`.

```sql filename="./migration/add-webauthn-authenticator-table.sql"
-- CreateTable
CREATE TABLE "Authenticator" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "credentialID" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "credentialPublicKey" TEXT NOT NULL,
    "counter" INTEGER NOT NULL,
    "credentialDeviceType" TEXT NOT NULL,
    "credentialBackedUp" BOOLEAN NOT NULL,
    "transports" TEXT,
    CONSTRAINT "Authenticator_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "Authenticator_credentialID_key" ON "Authenticator"("credentialID");
```

### Update Auth.js Configuration

Add the `Passkeys` provider to your configuration. Also make sure you're using a compatible database adapter.

```ts filename="./auth.ts"
import Passkey from "next-auth/providers/passkey"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { PrismaClient } from "@prisma/client"

const prisma = new PrismaClient()

export default {
  adapter: PrismaAdapter(prisma),
  providers: [Passkey],
  experimental: { enableWebAuthn: true },
}
```

If you're using the built-in Auth.js pages, then you are good to go now! Navigating to your `/signin` route should include a "Signin with Passkeys" button now.

### Custom Pages

If you're using a custom signin page, you can leverage the `next-auth` `signIn` function to initiate a WebAuthn registration and login with the following code. Remember, when using the WebAuthn `signIn` function, you'll also need the `@simplewebauth/browser` peer dependency installed.

```ts filename="app/login/page.tsx"
"use client"

import { useSession } from "next-auth/react"
import { signIn } from "next-auth/webauthn"

export default function Login() {
  const { data: session, update, status } = useSession()

  return (
    <div>
      {status === "authenticated" ? (
        <button onClick={() => signIn("passkey", { action: "register" })}>
          Register new Passkey
        </button>
      ) : status === "unauthenticated" ? (
        <button onClick={() => signIn("passkey")}>Sign in with Passkey</button>
      ) : null}
    </div>
  )
}
```

  </Steps>

<Callout>
WebAuthn support is currently not supported in `edge` environments out of the box due to an issue with an upstream library and `crypto` support.

</Callout>

</RichTabs.Content>

<RichTabs.Content className="p-8" key="external-auth" value="credentials">

To setup Auth.js with external authentication mechanisms or simply use username and password, we need to use the `CredentialsProvider`. This provider is designed to forward any credentials inserted into the login form (.i.e username/password) to your authentication service via the `authorize` callback on the provider configuration.

<Steps>

### Credentials Provider

First, lets initialise the `CredentialsProvider` in the Auth.js configuration file.

<Code>
<Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import Credentials from "next-auth/providers/credentials"

export const { handlers, auth } = NextAuth({
  providers: [
    Credentials({
      // You can specify which fields should be submitted, by adding keys to the `credentials` object.
      // e.g. domain, username, password, 2FA token, etc.
      credentials: {
        email: {},
        password: {},
      },
      authorize: async (credentials) => {
        let user = null

        // logic to salt and hash password
        const pwHash = saltAndHashPassword(credentials.password)

        // logic to verify if user exists
        user = await getUserFromDb(credentials.email, pwHash)

        if (!user) {
          throw new Error("User not found.")
        }

        // return json object with the user data
        return user
      },
    }),
  ],
})
```

</Code.Next>
<Code.Svelte>

First, we'll need to setup our Auth.js configuration file with the Credentials provider.

```ts filename="./src/auth.ts"
import { SvelteKitAuth } from "@auth/sveltekit"
import Credentials from "@auth/sveltekit/providers/credentials"

export const { signIn, signOut, handle } = SvelteKitAuth({
  providers: [
    Credentials({
      // You can specify which fields should be submitted, by adding keys to the `credentials` object.
      // e.g. domain, username, password, 2FA token, etc.
      credentials: {
        email: {},
        password: {},
      },
      authorize: async (credentials) => {
        let user = null

        // logic to salt and hash password
        const pwHash = saltAndHashPassword(credentials.password)

        // logic to verify if user exists
        user = await getUserFromDb(credentials.email, pwHash)

        if (!user) {
          throw new Error("User not found.")
        }

        // return json object with the user data
        return user
      },
    }),
  ],
})
```

</Code.Svelte>
</Code>

<Callout type="info">
  If you're using TypeScript, you can [augment the `User`
  interface](/getting-started/typescript#module-augmentation) to match the
  response of your `authorize` callback, so whenever you read the user in other
  callbacks (like the `jwt`) the type will match correctly.
</Callout>

### Signin Form

Finally, lets create a simple sign in button.

<Code>
<Code.Next>

```tsx filename="./components/sign-in.tsx"
"use client"

import { useState } from "react"
import { signIn } from "../../auth.ts"

export function SignIn() {
  const [email, setEmail] = useState("")
  const [password, setPassword] = useState("")
  return (
    <form
      action={async () => {
        "use server"
        await signIn("credentials", {
          // Note: The CredentialsProvider is non-opinionated, username/password is the simplest use-case,
          // but can be configured to work with many other authentication mechanisms and inputs.
          email,
          password,
        })
      }}
    >
      <label>
        Email
        <input
          name="email"
          type="email"
          onChange={(e) => setEmail(e.target.value)}
          value={email}
        >
      </label>
      <label>
        Password
        <input
          name="password"
          type="password"
          onChange={(e) => setPassword(e.target.value)}
          value={password}
        >
      </label>
      <button type="submit">Sign In</button>
    </form>
  )
}
```

</Code.Next>
<Code.Svelte>

```ts filename="src/route/+page.svelte"
  <script>
  import { signIn, signOut } from '../auth'
  import { page } from '$app/stores'

  let email = ''
  let password = ''
  </script>

  <div>
    <form>
      <label>
        Email
        <input name="email" type="email" bind:value={email}>
      </label>
      <label>
        Password
        <input name="password" type="password" bind:value={password}>
      </label>
      <button on:click={() => signIn('credentials', { email, password })}>Log in</button>
    </form>
  </div>
```

</Code.Svelte>
</Code>

</Steps>

## Verifying Data with Zod

To improved the security of your `CredentialsProvider` use, we can leverage a run-time schema validation library like [Zod](https://www.npmjs.com/package/zod) to validate that the inputs match what we expect.

First, we'll install the Zod dependency.

```bash npm2yarn
npm install zod
```

Next, we'll setup the schema and parsing in our `auth.ts` configuration file, using the `authorize` callback on the `CredentialsProvider`.

<Code>
<Code.Next>

```ts filename="./lib/zod.ts"
import { TypeOf, object, string } from "zod"

export const signInSchema = object({
  email: string({ required_error: "Email is required" })
    .min(1, "Email is required")
    .email("Invalid email"),
  password: string({ required_error: "Password is required" })
    .min(1, "Password is required")
    .min(8, "Password must be more than 8 characters")
    .max(32, "Password must be less than 32 characters"),
})
```

```ts filename="./auth.ts" {19}
import NextAuth from "next-auth"
import { ZodError } from "zod"
import Credentials from "next-auth/providers/credentials"
import { signInSchema } from "./lib/zod"

export const { handlers, auth } = NextAuth({
  providers: [
    Credentials({
      // You can specify which fields should be submitted, by adding keys to the `credentials` object.
      // e.g. domain, username, password, 2FA token, etc.
      credentials: {
        email: {},
        password: {},
      },
      authorize: async (credentials) => {
        try {
          let user = null

          const { email, password } = await createUserSchema.parseAsync(
            credentials
          )

          // logic to salt and hash password
          const pwHash = saltAndHashPassword(password)

          // logic to verify if user exists
          user = await getUserFromDb(email, pwHash)

          if (!user) {
            throw new Error("User not found.")
          }

          // return json object with the user data
          return user
        } catch (error) {
          if (error instanceof ZodError) {
            // Return `null` to indicate that the credentials are invalid
            return null
          }
        }
      },
    }),
  ],
})
```

</Code.Next>
<Code.Svelte>

```ts filename="./lib/zod.ts"
import { TypeOf, object, string } from "zod"

export const signInSchema = object({
  email: string({ required_error: "Email is required" })
    .min(1, "Email is required")
    .email("Invalid email"),
  password: string({ required_error: "Password is required" })
    .min(1, "Password is required")
    .min(8, "Password must be more than 8 characters")
    .max(32, "Password must be less than 32 characters"),
})
```

```ts filename="./auth.ts" {19}
import SvelteKitAuth from "@auth/sveltekit"
import { ZodError } from "zod"
import Credentials from "@auth/sveltekit/providers/credentials"
import { signInSchema } from "./lib/zod"

export const { handlers, auth } = SvelteKitAuth({
  providers: [
    Credentials({
      // You can specify which fields should be submitted, by adding keys to the `credentials` object.
      // e.g. domain, username, password, 2FA token, etc.
      credentials: {
        email: {},
        password: {},
      },
      authorize: async (credentials) => {
        try {
          let user = null

          const { email, password } = await createUserSchema.parseAsync(
            credentials
          )

          // logic to salt and hash password
          const pwHash = saltAndHashPassword(password)

          // logic to verify if user exists
          user = await getUserFromDb(email, pwHash)

          if (!user) {
            throw new Error("User not found.")
          }

          // return json object with the user data
          return user
        } catch (error) {
          if (error instanceof ZodError) {
            // Return `null` to indicate that the credentials are invalid
            return null
          }
        }
      },
    }),
  ],
})
```

</Code.Svelte>
</Code>

<Callout type="warning">
  The industry has come a long way since usernames and passwords were first
  introduced as the go-to mechanism for authenticating and authorizing users to
  web applications. Therefore, if possible, we recommend a more modern and
  secure authentication mechanism such as any of the [OAuth
  providers](/getting-started/authentication?tab=oauth), [Email Magic
  Links](/getting-started/authentication?tab=magic-link), or [WebAuthn
  (Passkeys)](/getting-started/authentication?tab=webauthn) instead of username
  / password. However, we also want to be flexible and support anything you deem
  appropriate for your application and use-case.
</Callout>

</RichTabs.Content>
</RichTabs>

### Next Steps

Now, start your development server and login with your chosen provider. After a successful login, you can navigate to `/api/auth/session` where you should see the Auth.js session json blob.

import SessionWorking from "../../public/img/getting-started/authentication-get-started.png"

<Screenshot
  className="mb-12 max-w-xl mx-auto w-full"
  src={SessionWorking}
  alt="Auth.js Session"
/>

If you've gotten this far, you can be confident that your user is authenticated and your setup is working. See the next section, [Session management](/getting-started/session-management), to learn how to manage and display the user's session in your application.
