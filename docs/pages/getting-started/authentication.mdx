import { Steps, Callout, Tabs } from "nextra/components"
import { Link } from "@/components/Link"
import { SelectProvider } from "@/components/SelectProvider"
import { RichTabs } from "@/components/RichTabs"
import { Code } from "@/components/Code"
import { Screenshot } from "@/components/Screenshot"
import { OAuthInstructions } from "@/components/OAuthInstructions"
import { TokenAuthInstructions } from "@/components/TokenAuthInstructions"
import { GitDiff, Password, ChatDots, Fingerprint } from "@phosphor-icons/react"
import { ListDisclosure } from "@/components/ListDisclosure"
import manifest from "@/data/manifest.json"

# Authentication

At this point, you need to decide how you're gonna authenticate users in your application. Auth.js supports three main authentication paradigms.

- [OAuth authentication](/getting-started/providers/oauth-tutorial) (_Sign in with Google, Github, LinkedIn, etc..._)
- [Passwordless authentication](/getting-started/providers/email-tutorial) (_Magic links, OTP codes, etc..._)
- [Credentials](/getting-started/providers/credentials-tutorial) (_Integrating with external APIs, etc..._)

<br />

<details>
<summary>
<b>Why does Auth.js recommend OAuth as the primary authentication method for your application?</b>
</summary>

OAuth providers spend significant amounts of money, time, and engineering effort to build abuse detection (_bot-protection, rate-limiting_), password management (_password reset, credential stuffing, rotation_), data security (_encryption/salting, strength validation_), and much more. It is likely that your application would benefit from leveraging these battle-tested solutions rather than try to rebuild them from scratch.

</details>
<details>
<summary>
<b>Do I need a database?</b>
</summary>

Auth.js by default uses [JSON Web Tokens](https://jwt.io/) for saving the user's session so you don't need to setup a database for authenticating users (_all of our JWT tokens are encrypted by default with `A256CBC-HS512`_). However, if you want to set up a database, you can use one of our official database adapters or create your own. The database will be used to persist the user's session. You can also force saving the users session in a JWT still when using a database adapter through the configuration options.

</details>
<details>
<summary>
<b>Can I set up more than one authentication method?</b>
</summary>

You can setup as many authentication methods as you'd like. But keep in mind, OAuth providers like Google and GitHub spend significant amounts of time, money, and engineering effort to build features such as abuse detection (_bot-protection, rate-limiting_), password management (_password reset, credential stuffing, rotation_), data security (_encryption/salting, strength validation_), and much more. It is likely that your application would benefit from leveraging these battle-tested solutions rather than try to rebuild them from scratch.

</details>

Once you have decided how to authenticate users in your application (you can always add more authentication methods later), click on the instructions below for the initial setup.

<RichTabs defaultValue="oauth">
  <RichTabs.List className="gap-2">
    <RichTabs.Trigger key="oauth" value="oauth">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <GitDiff fontSize="2.5rem" />
        <span>Setup OAuth</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger key="token-auth" value="passwordless">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <ChatDots fontSize="2.5rem" />
        <span>Passwordless</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger key="external-auth" value="credentials">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <Password fontSize="2.5rem" />
        <span>Setup Credentials</span>
      </div>
    </RichTabs.Trigger>
    <RichTabs.Trigger key="webauthn" value="webauthn">
      <div className="flex flex-col justify-center gap-1 items-center h-full">
        <Fingerprint fontSize="2.5rem" />
        <span>WebAuthn</span>
      </div>
    </RichTabs.Trigger>
  </RichTabs.List>
  <RichTabs.Content className="p-8" key="oauth" value="oauth">
    <SelectProvider />
  </RichTabs.Content>

<RichTabs.Content className="p-8" key="token-auth" value="passwordless">
  <TokenAuthInstructions />
</RichTabs.Content>

<RichTabs.Content className="p-8" key="webauthn" value="webauthn">
  <Callout type="warning">
    The WebAuthn / Passkeys provider is experimental and not recommended for
    production use.
  </Callout>
  The WebAuthn provider requires changes to all of the framework integration as well as any database adapter that plans to support it. Therefore, the WebAuthn provider is currently only supported in the following framework integration and database adapters. Support for more frameworks and adapters are coming soon.
- `next-auth@5.0.0-beta.8` or above
- `@auth/prisma-adapter@1.3.0` or above

<Steps>

### Install peer dependencies

```bash npm2yarn
npm install @simplewebauthn/browser @simplewebauthn/server
```

The `@simplewebauthn/browser` peer dependency is only required for custom signin pages. If you're using the Auth.js default pages, you can skip installing that peer dependency.

### Apply the required schema Migrations

This is the raw SQL migration, for more details including an example MongoDB migration, check out the Prisma `schema.prisma` [here](https://github.com/Maronato/next-auth/blob/main/packages/adapter-prisma/prisma/schema.prisma), or the PR adding support to Prisma [here](https://github.com/nextauthjs/next-auth/pull/9876).

In short, the Passkeys provider requires an additional table called `Authenticator`.

```sql filename="./migration/add-webauthn-authenticator-table.sql"
-- CreateTable
CREATE TABLE "Authenticator" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "credentialID" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "credentialPublicKey" TEXT NOT NULL,
    "counter" INTEGER NOT NULL,
    "credentialDeviceType" TEXT NOT NULL,
    "credentialBackedUp" BOOLEAN NOT NULL,
    "transports" TEXT,
    CONSTRAINT "Authenticator_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "Authenticator_credentialID_key" ON "Authenticator"("credentialID");
```

### Update Auth.js Configuration

Add the `Passkeys` provider to your configuration. Also make sure you're using a compatible database adapter.

```ts filename="./auth.ts"
import Passkey from "next-auth/providers/passkey"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { PrismaClient } from "@prisma/client"

const prisma = new PrismaClient()

export default {
  adapter: PrismaAdapter(prisma),
  providers: [Passkey],
  experimental: { enableWebAuthn: true },
}
```

If you're using the built-in Auth.js pages, then you are good to go now! Navigating to your `/signin` route should include a "Signin with Passkeys" button now.

### Custom Pages

If you're using a custom signin page, you can leverage the `next-auth` `signIn` function to initiate a WebAuthn registration and login with the following code. Remember, when using the WebAuthn `signIn` function, you'll also need the `@simplewebauth/browser` peer dependency installed.

```ts filename="app/login/page.tsx"
"use client"

import { useSession } from "next-auth/react"
import { signIn } from "next-auth/webauthn"

export default function Login() {
  const { data: session, update, status } = useSession()

  return (
    <div>
      {status === "authenticated" ? (
        <button onClick={() => signIn("passkey", { action: "register" })}>
          Register new Passkey
        </button>
      ) : status === "unauthenticated" ? (
        <button onClick={() => signIn("passkey")}>Sign in with Passkey</button>
      ) : null}
    </div>
  )
}
```

  </Steps>

<Callout>
WebAuthn support is currently not supported in `edge` environments out of the box due to an issue with an upstream library and `crypto` support.

</Callout>

</RichTabs.Content>

<RichTabs.Content className="p-8" key="external-auth" value="credentials">

To setup Auth.js with external authentication mechanisms or simply use username and password, we need to use the `CredentialsProvider`. This provider is designed to forward any credentials inserted into the login form (.i.e username/password) to your authentication service via the `authorize` callback on the provider configuration.

<Callout type="warning">
  The industry has come a long way since usernames and passwords were first
  introduced as the go-to mechanism for authenticating and authorizing users to
  web applications. Therefore, if possible, we recommend a more modern and
  secure authentication mechanism such as any of the OAuth providers, Email
  Magic Links, or WebAuthn (Passkeys) instead of username / password. However,
  we also want to be flexible and support anything you deem appropriate for your
  application and use-case.
</Callout>

<Steps>

### Credentials Provider

First, lets initialise the `CredentialsProvider` in the Auth.js configuration file.

<Code>
<Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import Credentials from "next-auth/providers/credentials"

export const { handlers, auth } = NextAuth({
  providers: [
    Credentials({
      // `credentials` will usually contain the collected user's credentials
      // forwarded through the `signIn()` helper.
      async authorize(credentials) {
        // You can call here your external API or run the logic to authenticate the
        // user using the collected credentials
        const authResponse = await fetch("/users/login", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(credentials),
        })

        if (!authResponse.ok) {
          return null
        }

        const user = await authResponse.json()

        return user
      },
    }),
  ],
})
```

</Code.Next>
<Code.Svelte>

First, we'll need to setup our Auth.js configuration file with the Credentials provider.

```ts filename="./src/auth.ts"
import { SvelteKitAuth } from "@auth/sveltekit"
import Credentials from "@auth/sveltekit/providers/credentials"

export const { signIn, signOut, handle } = SvelteKitAuth({
  providers: [
    Credentials({
      // `credentials` will usually contain the collected user's credentials
      // forwarded through the `signIn()` helper.
      async authorize(credentials) {
        // You can call here your external API or run the logic to authenticate the
        // user using the collected credentials
        const authResponse = await fetch("/users/login", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(credentials),
        })

        if (!authResponse.ok) {
          return null
        }

        const user = await authResponse.json()

        return user
      },
    }),
  ],
})
```

<Callout type="info">
  Check the [Credentials Provider
  options](/reference/core/providers/credentials) for further customization
</Callout>

</Code.Svelte>
</Code>

<Callout type="info">
  If you're using TypeScript, you can [augment the `User`
  interface](/getting-started/typescript#module-augmentation) to match the
  response of your `authorize` callback, so whenever you read the user in other
  callbacks (like the `jwt`) the type will match correctly.
</Callout>

### Signin Button

Finally, lets create a simple sign in button.

<Code>
<Code.Next>

```tsx filename="./components/sign-in.tsx"
import { signIn } from "../../auth.ts"

export function SignIn() {
  return (
    <form
      action={async () => {
        "use server"
        await signIn("credentials", {
          // Note: The credentials (username/password) will usually be collected through a sign in form you have you build yourself.
          //       The CredentialsProvider is non-opinionated, username/password is the simplest use-case, but can be configured to work with many other authentication mechanisms.
          username: "foo@foo.com",
          password: "helloworld",
        })
      }}
    >
      <button type="submit">Sign In</button>
    </form>
  )
}
```

</Code.Next>
<Code.Svelte>

If you want to take advantage of the Auth.js built-in default pages, we can use the client-side `signIn` method to redirect the user to the signin page when clicked. To setup a custom page, check out the [SvelteKit Custom Page](/getting-started/session-management?tab=custom-pages) documentation.

```ts filename="src/components/navbar.svelte"
<script lang="ts">
  import { signIn } from "@auth/sveltekit/client"
</script>

<nav>
  <button on:click={signIn}>Sign In</button>
</nav>
```

</Code.Svelte>
</Code>

</Steps>

</RichTabs.Content>
</RichTabs>

### Next Steps

If you now navigate in your app to `/api/auth/session`, should see the Auth.js session displayed as a JSON:

import SessionWorking from "../../public/img/getting-started/authentication-get-started.png"

<Screenshot
  className="mb-12 max-w-xl mx-auto w-full"
  src={SessionWorking}
  alt="Auth.js Session"
/>

If you've gotten this far, you can be confident that your user is authenticated and
your setup is working. See the next section, [Session management](/getting-started/session-management),
to learn how to manage and display the user's session in your application.
